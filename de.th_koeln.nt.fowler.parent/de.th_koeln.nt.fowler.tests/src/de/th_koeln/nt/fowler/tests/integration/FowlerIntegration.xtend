/*
 * generated by Xtext 2.12.0
 */
package de.th_koeln.nt.fowler.tests.integration

import com.google.inject.Inject
import de.th_koeln.nt.fowler.fowler.Statemachine
import de.th_koeln.nt.fowler.tests.FowlerInjectorProvider
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.eclipse.xtext.xbase.testing.CompilationTestHelper
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(typeof(XtextRunner))
@InjectWith(typeof(FowlerInjectorProvider))
class FowlerIntegration {
	@Inject extension ParseHelper<Statemachine>
	@Inject extension ValidationTestHelper
	@Inject extension CompilationTestHelper

	def String trafficLightControl() {
		'''
			events
				buttonPressed BP
				timeExpired TE
				waited W
			end
			
			resetEvents
				timeExpired
			end
			
			commands
				carLightRed CLR
				carLightYellow CLY
				carLightGreen CLG
				
				pedestrianLightRed PLR
				pedestrianLightGreen PLG
				
				start4Sec S4S
				start20Sec S20S
			end
			
			state idle
				actions {carLightGreen pedestrianLightRed}
				buttonPressed => wait1
			end
			
			state wait1
				actions{carLightYellow pedestrianLightRed start4Sec}
				waited => idle
			end
		'''
	}

	@Test
	def void testGeneratedCode() {
		trafficLightControl.parse => [
			Assert.assertNotNull("Das Result ist nicht null.", it)
			assertNoErrors
		]
		
		trafficLightControl.assertCompilesTo('''
		digraph finite_state_machine {
			size="8,5"
			node [shape = record, style = rounded];
		
			idle[label="{idle|CLG PLR }"];
			wait1[label="{wait1|CLY PLR S4S }"];
			
			idle -> wait1 [ label = "buttonPressed" ];
			wait1 -> idle [ label = "waited" ];
		
			node [shape = box, style = filled, color=azure2]
			resetEvents[label="Reset Events:\n\ntimeExpired"]
		}
		''')

	}

}
